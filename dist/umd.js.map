{"version":3,"file":"umd.js","sources":["../src/hooks/from.ts","../src/operators/until.ts","../src/use-rx.ts","../src/operators/error-utils.ts","../src/operators/map-error.ts","../src/operators/tap-error.ts","../src/rx-refs/sync-ref.ts","../src/rx-refs/from-ref.ts","../src/rx-refs/ref-from.ts","../src/rx-refs/refs-from.ts","../src/operators/set-ref.ts"],"sourcesContent":["import { Observable } from 'rxjs';\nimport { getCurrentInstance } from 'vue';\n\nexport type VueHook = (hook: () => any, ...args: any[]) => any;\n\n/**\n * Creates an observable that emits when a vue hook is executed\n *\n * If subscribed to outside the component scope - equivalent to a NEVER observable\n *\n * @param hook the vue hook to listen to\n *\n * for example: onUnmounted, onActivated, onUpdated, etc.\n *\n * ---\n */\nexport const fromHook = (hook: VueHook) => new Observable<void>(\n  ctx => { getCurrentInstance() && hook(() => ctx.next()) }\n);\n","import type { Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { onUnmounted } from 'vue';\nimport { VueHook, fromHook } from '../hooks/from';\n\n/**\n * Creates an takeUntil that emits when a vue hook is executed\n *\n * @param hook the vue hook to listen to\n *\n * for example: onUnmounted, onActivated, onUpdated, etc.\n *\n * ---\n */\nexport const pipeUntil = <T>(hook: VueHook) => takeUntil<T>(fromHook(hook));\n\n/**\n * Stops an observable when a vue component is unmounted\n *\n * @param $ - obserable to stop on unmounted\n *\n * ---\n */\nexport const untilUnmounted: <T>($: Observable<T>) => Observable<T> = pipeUntil(onUnmounted);\n","import { isObservable, merge, of, Subject } from 'rxjs';\nimport { map, mergeScan, scan, tap } from 'rxjs/operators';\nimport { reactive, readonly } from 'vue';\nimport { untilUnmounted } from './operators/until';\n\nimport type { Observable, PartialObserver, Subscription } from 'rxjs';\nimport type { DeepReadonly, Ref, UnwrapRef } from 'vue';\n\nexport interface MutationStrategy<S extends Record<PropertyKey, any>> {\n  /**\n   * Creates a mutation applier\n   *\n   * @param state - a base state to mutate\n   * @param strategy - current mutation strategy\n   */\n  (state: S, strategy: MutationStrategy<S>): (\n    mutation: S | DeepPartial<S>\n  ) => S;\n}\n\nexport interface RxStateOptions<S> {\n  mutationStrategy: MutationStrategy<S>;\n}\n\n/**\n * Allows to bind reducers to a state and an observable.\n *\n * First accepts state's default value and a state merge strategy,\n * then accepts a map of state reducers.\n *\n * @param initialState - a factory or initial value for the reactive state\n * @param options - options to customize the behavior, for example - to apply a custom strategy of merging a mutation with an old state\n */\nexport function useRxState<T extends Record<string, any>>(\n  initialState: T | (() => T),\n  options: Partial<RxStateOptions<UnwrapNestedRefs<T>>> = defaultOptions\n): CreateRxState<UnwrapNestedRefs<T>> {\n  const {\n    mutationStrategy: mergeKeys,\n  } = { ...defaultOptions, ...options };\n\n  return function (reducers, map$?) {\n    type S = UnwrapNestedRefs<T>;\n    type ReducerResult = ReturnType<StateReducer<S>>;\n    type Actions = ReducerActions<typeof reducers>;\n\n    const state = reactive(maybeCall(initialState));\n\n    const actions = <Actions> {};\n    const actions$ = <ReducerObservables<Actions, S>> {};\n    const actions$Arr = <Observable<S>[]> [];\n\n    for (const key in reducers) {\n      const mutations$ = new Subject<ReducerResult>();\n\n      actions[key] = <ReducerAction<typeof reducers[typeof key]>>(\n        (...args: any[]) => mutations$.next(\n          reducers[key].apply(reducers, args)\n        )\n      );\n\n      actions$Arr.push(\n        actions$[`${key}$` as const] = (\n          mergeScan((prev: S, curr: ReducerResult) => {\n            let complete = false;\n            let error: any = undefined;\n\n            curr = maybeCall(curr, prev, {\n              error: e => { error = e },\n              complete: () => { complete = true }\n            });\n\n            return (\n              isObservable(curr)\n                ? curr\n                : of(curr)\n            ).pipe(\n              map(mergeKeys(prev, mergeKeys)),\n              tap(() => (\n                complete\n                  ? mutations$.complete()\n                  : error && mutations$.error(error)\n              ))\n            )\n          }, state)(mutations$)\n        )\n      );\n    }\n\n    const merged$ = merge(...actions$Arr);\n\n    return createRxResult({\n      actions,\n      state: readonly(state as T),\n      state$: untilUnmounted(\n        map$ ? map$(\n          merged$,\n          reducers,\n          state,\n          actions$,\n        ).pipe(\n          scan((prev, curr) => (mergeKeys(prev, mergeKeys)(curr)), state)\n        ) : merged$\n      ),\n      actions$: actions$ as ReducerObservables<Actions, DeepReadonly<S>>,\n    });\n  };\n}\n\ntype CreateRxState<S> = {\n  /**\n   * Allows to bind reducers to a state and an observable.\n   *\n   * Accepts a map of state reducers.\n   *\n   * Each reducer can either return:\n   * * an updated part of the state:\n   *   ```\n   *   (v) => ({ value: v })\n   *   ```\n   * * an observable that emits an updated part of the state:\n   *   ```\n   *   (v) => new BehaviorSubject({ value: v })\n   *   ```\n   * * a function that accepts the old state and returns either of the previous types:\n   *   ```\n   *   (v) => (oldState) => ({\n   *       value: oldState.value > v ? oldState.value : v\n   *   })\n   *   ```\n   *\n   * @param initialState an initial value for the reactive state\n   * @param mergeStrategy a strategy of merging a mutation with an old state\n   */\n  <R extends StateReducers<S>>(\n    reducers: R,\n    map$?: (\n      state$: Observable<S>,\n      reducers: R,\n      state: S,\n      actions$: Record<Action$<Extract<keyof R, string>>, Observable<S>>\n    ) => Observable<DeepPartial<S>>\n  ): SubscribableRxRes<ReducerActions<R>, S>;\n};\n\n/**\n * Checks if it's possible to advance deeper\n * into the sibling object structures,\n * with one being partial\n *\n * @param state - the object source\n * @param mutation - the main checking reference\n * @param key - a key into which to advance\n */\nexport const canMergeDeep = <S extends Record<PropertyKey, any>>(\n  state: S,\n  mutation: S | DeepPartial<S>,\n  key: keyof S,\n) =>  (\n  typeof mutation[key] === 'object'\n  && mutation !== null\n  && typeof state[key] === 'object'\n);\n\n/**\n * Default merge strategy for mutations\n *\n * Merges state and mutation recursively,\n * by enumerable keys (`for..in`),\n * so avoid recursive object links\n */\nexport const deepMergeKeys = <S extends Record<PropertyKey, any>>(\n  state: S\n) => (\n  mutation: DeepPartial<S>\n) => {\n  for (const key in mutation) {\n    state[key] = canMergeDeep(state, mutation, key)\n      ? deepMergeKeys(state[key])(mutation[key])\n      : mutation[key] as any;\n  }\n\n  return state;\n};\n\nconst defaultOptions: RxStateOptions<any> = {\n  mutationStrategy: deepMergeKeys,\n};\n\nconst createRxResult = <S, Actions>(result: {\n  actions: Actions,\n  state: DeepReadonly<S>,\n  state$: Observable<S>,\n  actions$: ReducerObservables<Actions, DeepReadonly<S>>\n}): SubscribableRxRes<Actions, S> => ({\n  ...result,\n  subscribe: (...args: any[]) => ({\n    ...result,\n    subscription: result.state$.subscribe(...args),\n  }),\n})\n\nconst maybeCall = <T, A extends any[]>(\n  fn: T | ((...args: A) => T),\n  ...args: A\n) => (\n  typeof fn === 'function'\n    ? (fn as (...args: A) => T)(...args)\n    : fn\n);\n\ntype Builtin =\n  | Function\n  | Date\n  | Error\n  | RegExp\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | bigint\n  | symbol\n  | undefined\n  | null;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends Record<any, any>\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRef<T>;\n\nexport type MutationContext = {\n  error(error: any): void;\n  complete(): void;\n}\n\nexport type Mutation<S> =\n  // | void\n  // isn't useful,\n  // need to keep reducers explicit in what they do\n  | S\n  | DeepPartial<S>\n  | Observable<DeepPartial<S>>;\n\n/**\n * A reducer for the observable state\n */\nexport type StateReducer<S, Args extends any[] = any[]> = (...args: Args) =>\n  | Mutation<S>\n  | ((state: S, mutation: MutationContext) => Mutation<S>)\n  ;\n\n/**\n * A named collection of state reducers\n */\nexport type StateReducers<S> = Record<string, StateReducer<S>>;\n\n/**\n * A method action generated from a StateReducer\n */\nexport type ResAction<A extends any[] = []> = (...args: A) => void;\n\n/**\n * Resulting RX bindings:\n *\n * * actions - a named collection of ResAction-s\n * * state - a reactive vue state\n * * state$ - an rxjs observable\n */\nexport type RxResult<\n  Actions,\n  State,\n  RState = DeepReadonly<State>\n> = {\n  readonly actions: Actions;\n  readonly state: RState;\n  readonly state$: Observable<State>;\n};\n\ntype Action$<Name extends string> = `${Name}$`;\n\ntype ReducerObservables<H, R> = {\n  [key in Action$<Extract<keyof H, string>>]: Observable<R>;\n};\n\nexport type SubscribableRxRes<\n  Actions,\n  State,\n  RState = DeepReadonly<State>\n> = RxResult<Actions, State, RState> & {\n  readonly actions$: ReducerObservables<Actions, RState>;\n  readonly subscribe: PipeSubscribe<SubscribableRxRes<Actions, State, RState>, State>;\n};\n\nexport type PipeSubscribe<Res extends SubscribableRxRes<any, any>, S> = {\n  (observer?: PartialObserver<S>): Omit<Res, 'subscribe'> & {\n    readonly subscription: Subscription;\n  };\n  (...args: Parameters<Observable<S>['subscribe']>): Omit<Res, 'subscribe'> & {\n    readonly subscription: Subscription;\n  };\n};\n\ntype ReducerAction<R> = R extends StateReducer<any, infer Args>\n  ? ResAction<Args>\n  : never;\n\ntype ReducerActions<R> = { [key in keyof R]: ReducerAction<R[key]> };\n","import type { Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nexport const createErrorOperator = (\n  operation: (e: any, $: Observable<any>, cb: (e: any, $: Observable<any>) => any) => void\n) => <T, O, R>(cb: (e: T, $: Observable<O>) => R) => (\n  catchError<O, Observable<O>>((e, $) => { throw operation(e, $, cb); })\n);\n","import { createErrorOperator } from './error-utils';\n\nexport const mapError = createErrorOperator((e, $, cb) => cb(e, $));\n","import { createErrorOperator } from './error-utils';\n\nexport const tapError = createErrorOperator((e, $, cb) => (cb(e, $), e));\n","import { Ref, UnwrapRef, ref, watch, WatchOptions, WatchStopHandle } from 'vue';\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The resulting ref serves as an origin point for the binding,\\\n * values **from** the resulting ref and **to** the resulting ref are mapped onto it.\n */\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { to }: { to: Mapper<R1, UnwrapRef<R2>> },\n): SyncedRef<R1, 'to', UnwrapRef<R2>>;\n\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { from }: { from: Mapper<UnwrapRef<R2>, R1> },\n  defaultValue?: R2,\n): SyncedRef<R1, 'from', UnwrapRef<R2>>;\n\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { to, from }: { to: Mapper<R1, UnwrapRef<R2>>, from: Mapper<UnwrapRef<R2>, R1> },\n): SyncedRef<R1, 'to' | 'from', UnwrapRef<R2>>;\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The resulting ref serves as an origin point for the binding,\\\n * values **from** the resulting ref and **to** the resulting ref are mapped onto it.\n */\n export function syncRef<R1, R2, M extends Readonly<Mappers<R1, R2>> = Mappers<R1, R2>>(\n  ref1: Ref<R1>,\n  { to, from }: M,\n  defaultValue?: R2,\n): SyncedRef<R1, keyof M, UnwrapRef<R2>>;\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The second ref serves as an origin point for the binding,\\\n * values **from** the second ref and **to** the second ref are mapped onto it.\n */\nexport function syncRef<R1, R2, M extends Readonly<Mappers<R1, R2>> = Mappers<R1, R2>>(\n  ref1: Ref<R1>,\n  { to, from }: M,\n  ref2: Ref<R2>,\n): SyncedRef<R1, keyof M, R2>;\n\nexport function syncRef<R1, R2>(\n  this: WatchOptions,\n  ref1: Ref<R1>,\n  maps: Readonly<Mappers<R1, R2>>,\n  _ref2?: Ref<R2> | R2,\n): _SyncedRef<R1, keyof Mappers<R1, R2>, R2> {\n  const ref2 = ref(\n    _ref2\n      ?? maps.to?.(ref1.value)\n      ?? ref1.value\n  ) as _SyncedRef<R1, keyof Mappers<R1, R2>, R2>;\n\n  for (const key in maps) {\n    ref2[key] = {};\n\n    bind(ref1, ref2, maps, key as any, this)();\n  }\n\n  return ref2;\n}\n\nsyncRef.with = <T extends Readonly<boolean> = false>(\n  ...options: WatchOptions<T>[]\n): typeof syncRef => {\n  const opts = Object.assign({}, ...options);\n  const f = syncRef.bind(opts);\n  f.with = syncRef.with.bind(opts);\n  return f;\n}\n\nconst bind = <R1, R2>(\n  refBase: Ref<R1>,\n  refDest: Ref<R2>,\n  maps: Mappers<R1, R2>,\n  dir: keyof Mappers<R1, R2>,\n  options: WatchOptions,\n) => refDest[dir].bind = (\n  ref = refBase,\n  map = maps[dir] as Mapper<any, any>,\n  opts?: WatchOptions\n) => {\n  if (refDest[dir].stop) {\n    refDest[dir].stop();\n  }\n\n  refDest[dir].stop = dir === 'to'\n    ? watch(ref, v => refDest.value = map(v), Object.assign({}, options, opts))\n    : watch(refDest, v => ref.value = map(v), Object.assign({}, options, opts));\n};\n\ntype Mapper<F, T> = (value: F) => T;\n\ntype Mappers<R1, R2> = {\n  /**\n   * A map from the first ref to the second\n   */\n  to: Mapper<R1, R2>,\n\n  /**\n   * A map from the second ref to the first\n   */\n  from?: never,\n} | {\n  /**\n   * A map from the first ref to the second\n   */\n  to?: never,\n\n  /**\n   * A map from the second ref to the first\n   */\n  from: Mapper<R2, R1>,\n} | {\n  /**\n   * A map from the first ref to the second\n   */\n  to: Mapper<R1, R2>,\n\n  /**\n   * A map from the second ref to the first\n   */\n  from: Mapper<R2, R1>,\n};\n\ntype Binders<R1, R2, Keys extends PropertyKey> = {\n  [key in Keys]: {\n    /**\n     * Cut the binding in this direction\n     */\n    stop: WatchStopHandle;\n    bind: {\n      /**\n       * Reapply the binding in this direction\n       */\n      (): void;\n\n      /**\n       * Bind this direction to a new ref\n       */\n      (ref: Ref<R1>): void;\n\n      /**\n       * Bind this direction to a new ref with a new map\n       */\n      <T>(ref: Ref<T>, map: key extends 'to' ? Mapper<T, R2> : Mapper<R2, T>, options?: WatchOptions): void;\n    };\n  };\n};\n\ntype SyncedRef<\n  R1,\n  Keys extends PropertyKey,\n  R2,\n> = Ref<R2> & Binders<R1, R2, Keys>;\n\ntype _SyncedRef<\n  R1,\n  _Keys extends PropertyKey,\n  R2,\n> = Ref<R2> & Partial<Binders<R1, R2, keyof Mappers<R1, R2>>>;\n","import { Observable } from 'rxjs';\nimport { watch, WatchOptions, WatchSource } from 'vue';\nimport { untilUnmounted } from '../operators/until';\n\n/**\n * Creates an observable from a vue ref.\n *\n * Each time a ref's value is changed - observable emits.\n *\n * Can also accept vue reactive objects and value factories.\n *\n * @param ref - a ref/reactive/factory to observe\n * @returns an observable that watches the ref\n */\nexport function fromRef<R>(ref: WatchSource<R>, options?: WatchOptions): Observable<R>;\n\n/**\n * Creates an observable from a vue reactive state.\n *\n * Each time a state's value is changed - observable emits.\n *\n * @param ref - a reactive state to observe\n * @returns an observable that watches the state\n */\nexport function fromRef<R extends Record<string, any>>(reactiveState: R, options?: WatchOptions): Observable<R>;\nexport function fromRef<R extends Record<string, any> | WatchSource<any>>(ref: R): Observable<R> {\n  return untilUnmounted(\n    new Observable<R>(ctx => watch(ref, value => ctx.next(value)))\n  );\n};\n","import { from, ObservableInput } from 'rxjs';\nimport { isProxy, Ref, ref, toRef, UnwrapRef } from 'vue';\n\n/**\n * Creates a ref from a promise.\n *\n * Once a promise is resolved, the ref is set to the resulting value.\n *\n * The ref will contain `undefined` until the promise is resolved.\n *\n * @param promise to set from\n */\nexport function refFrom<R>(promise: Promise<R>): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * Creates a ref from a promise.\n *\n * Once a promise is fulfilled, the ref is set to the resulting value.\n * Until then, the ref will contain the passed default value.\n *\n * @param promise to set from\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(promise: Promise<R>, defaultValue: R): Ref<UnwrapRef<R>>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n */\nexport function refFrom<R>(arg: R): Ref<UnwrapRef<R>>;\n\n/**\n * Creates a ref from an observable input.\n *\n * Behaves exactly like `from` in rxjs and creates an observable from the input.\n *\n * Once a resulting observable emits, the ref is set to the emitted value.\n *\n * The ref will contain `undefined` until the observable emits.\n *\n * @param observableInput an input to create an observable form and then listen to it\n */\nexport function refFrom<R>(obserableInput: ObservableInput<R>): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * Creates a ref from an observable input.\n *\n * Behaves exactly like `from` in rxjs and creates an observable from the input.\n *\n * Once a resulting observable emits, the ref is set to the emitted value.\n * Until then, the ref will contain the passed default value.\n *\n * @param observableInput an input to create an observable form and then listen to it\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(obserableInput: ObservableInput<R>, defaultValue: R): Ref<UnwrapRef<R>>;\n\n/**\n * Works exactly like toRef:\n * creates a ref from a reactive state.\n *\n * @param state a reactive state to bind from\n * @param key a key of the state to bind\n */\nexport function refFrom<R extends Record<any, any>, K extends keyof R>(state: R, key: K): Ref<UnwrapRef<R[K]>>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n */\nexport function refFrom<R>(arg: ObservableInput<R> | R): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(arg: ObservableInput<R> | R, defaultValue: R): Ref<UnwrapRef<R>>;\n\nexport function refFrom(arg: unknown, subArg?: unknown) {\n  if (typeof arg === 'object') try {\n    const ref$ = ref(subArg);\n\n    from(arg as any).subscribe(value => ref$.value = value);\n\n    return ref$;\n  } catch (_) { /* Silence the error to try another ways */ }\n\n  return isProxy(arg)\n    ? toRef(arg as Record<any, any>, subArg)\n    : ref(arg);\n}\n","import { ObservableInput, from, Subscription, Observable } from 'rxjs';\nimport { Ref, ref } from 'vue';\n\ntype Subscribers<R, E> = { next: R; error: E; };\n\ntype Refs<R, E> = {\n  [key in keyof Subscribers<R, E>]: Ref<Subscribers<R, E>[key]>;\n} & {\n  subscription: Subscription;\n  value$: Observable<R>;\n};\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * Until the observable emits, the refs will contain `undefined`.\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n */\nexport function refsFrom<R, E = unknown>(input: ObservableInput<R>): Refs<R | undefined, E | undefined>;\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n *\n * @param defaultValues\n * A map of default values for each ref.\n */\nexport function refsFrom<R, E = unknown>(input: ObservableInput<R>, defaultValues: { next: R }): Refs<R, E | undefined>;\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n *\n * @param defaultValues\n * A map of default values for each ref.\n */\nexport function refsFrom<R, E>(input: ObservableInput<R>, defaultValues: Subscribers<R, E>): Refs<R, E>;\n\nexport function refsFrom(input: ObservableInput<any>, defaultValues?: Partial<Subscribers<any, any>>) {\n  const next = ref(defaultValues?.next);\n  const error = ref(defaultValues?.error);\n  const value$ = from(input);\n\n  return {\n    next,\n    error,\n    value$,\n    subscription: value$.subscribe({\n      next: v => next.value = v,\n      error: v => error.value = v,\n    })\n  };\n}\n","import { tap } from 'rxjs/operators';\nimport { Ref } from 'vue';\n\nexport const setRef = <T>(ref: Ref<T>) => tap<T>(v => ref.value = v);\n"],"names":["fromHook","hook","Observable","ctx","getCurrentInstance","next","pipeUntil","takeUntil","untilUnmounted","onUnmounted","canMergeDeep","state","mutation","key","_typeof","deepMergeKeys","defaultOptions","mutationStrategy","createRxResult","result","subscribe","subscription","state$","maybeCall","fn","args","createErrorOperator","operation","cb","catchError","e","$","mapError","tapError","syncRef","ref1","maps","_ref2","ref2","ref","to","_maps$to","value","bind","this","options","opts","Object","assign","f","refBase","refDest","dir","map","stop","watch","v","arg","subArg","ref$","from","_","isProxy","toRef","input","defaultValues","error","value$","tap","initialState","mergeKeys","reducers","map$","reactive","actions","actions$","actions$Arr","mutations$","Subject","apply","push","mergeScan","prev","curr","complete","undefined","isObservable","of","pipe","merged$","merge","readonly","scan"],"mappings":"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"}