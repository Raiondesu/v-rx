{"version":3,"file":"umd.js","sources":["../src/hooks/from.ts","../src/hooks/until.ts","../src/use-rx.ts","../src/operators/error-utils.ts","../src/operators/map-error.ts","../src/operators/tap-error.ts","../src/rx-refs/from-ref.ts","../src/rx-refs/ref-from.ts","../src/rx-refs/refs-from.ts","../src/operators/set-ref.ts","../src/rx-refs/sync-ref.ts"],"sourcesContent":["import { Observable } from 'rxjs';\nimport { getCurrentInstance } from 'vue';\n\nexport type VueHook = (hook: () => any, ...args: any[]) => any;\n\n/**\n * Creates an observable that emits when a vue hook is executed\n *\n * If subscribed to outside the component scope - equivalent to a NEVER observable\n *\n * @param hook the vue hook to listen to\n *\n * for example: onUnmounted, onActivated, onUpdated, etc.\n *\n * ---\n */\nexport const fromHook = (hook: VueHook) => new Observable<void>(\n  ctx => { getCurrentInstance() && hook(() => ctx.next()) }\n);\n","import type { Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { onUnmounted } from 'vue';\nimport { VueHook, fromHook } from './from';\n\n/**\n * Creates an takeUntil that emits when a vue hook is executed\n *\n * If subscribed to outside the component scope - equivalent to a NEVER observable\n *\n * @param hook the vue hook to listen to\n *\n * for example: onUnmounted, onActivated, onUpdated, etc.\n *\n * ---\n */\nexport const pipeUntil = <T>(hook: VueHook) => takeUntil<T>(fromHook(hook));\n\n/**\n * Stops an observable when a vue component is unmounted\n *\n * If the resulting observable is subscribed to outside the component scope - it is equivalent to a NEVER observable\n *\n * @param obs - obserable to stop on unmounted\n *\n * ---\n */\nexport const untilUnmounted = <T>(obs: Observable<T>) => obs.pipe(pipeUntil(onUnmounted));\n","import { isObservable, merge, of, Subject } from 'rxjs';\nimport { map, mergeScan, scan, tap } from 'rxjs/operators';\nimport { reactive, readonly } from 'vue';\nimport { untilUnmounted } from './hooks/until';\n\nimport type { Observable, PartialObserver, Subscription } from 'rxjs';\nimport type { DeepReadonly, Ref, UnwrapRef } from 'vue';\n\nexport interface MutationStrategy<S extends Record<PropertyKey, any>> {\n  /**\n   * Creates a mutation applier\n   *\n   * @param state - a base state to mutate\n   * @param strategy - current mutation strategy\n   */\n  (state: S, strategy: MutationStrategy<S>): (\n    mutation: S | DeepPartial<S>\n  ) => S;\n}\n\nexport interface RxStateOptions<S> {\n  mutationStrategy: MutationStrategy<S>;\n}\n\n/**\n * Allows to bind reducers to a state and an observable.\n *\n * First accepts state's default value and a state merge strategy,\n * then accepts a map of state reducers.\n *\n * @param initialState - a factory or initial value for the reactive state\n * @param options - options to customize the behavior, for example - to apply a custom strategy of merging a mutation with an old state\n */\nexport function useRxState<T extends Record<string, any>>(\n  initialState: T | (() => T),\n  options: Partial<RxStateOptions<UnwrapNestedRefs<T>>> = defaultOptions\n): CreateRxState<UnwrapNestedRefs<T>> {\n  const {\n    mutationStrategy: mergeKeys,\n  } = { ...defaultOptions, ...options };\n\n  return function (reducers, map$?) {\n    type S = UnwrapNestedRefs<T>;\n    type ReducerResult = ReturnType<StateReducer<S>>;\n    type Actions = ReducerActions<typeof reducers>;\n\n    const state = reactive(maybeCall(initialState));\n\n    const actions = <Actions> {};\n    const actions$ = <ReducerObservables<Actions, S>> {};\n    const actions$Arr = <Observable<S>[]> [];\n\n    for (const key in reducers) {\n      const mutations$ = new Subject<ReducerResult>();\n\n      actions[key] = <ReducerAction<typeof reducers[typeof key]>>(\n        (...args: any[]) => mutations$.next(\n          reducers[key].apply(reducers, args)\n        )\n      );\n\n      actions$Arr.push(\n        actions$[`${key}$` as const] = (\n          mergeScan((prev: S, curr: ReducerResult) => {\n            let complete = false;\n            let error: any = undefined;\n\n            curr = maybeCall(curr, prev, {\n              error: e => { error = e },\n              complete: () => { complete = true }\n            });\n\n            return (\n              isObservable(curr) ? curr : of(curr)\n            ).pipe(\n              map(mergeKeys(prev, mergeKeys)),\n              tap(() => (\n                complete\n                  ? mutations$.complete()\n                  : error && mutations$.error(error)\n              ))\n            )\n          }, state)(mutations$)\n        )\n      );\n    }\n\n    const merged$ = merge(...actions$Arr);\n\n    return createRxResult({\n      actions,\n      state: readonly(state as T),\n      state$: untilUnmounted(\n        map$ ? map$(\n          merged$,\n          reducers,\n          state,\n          actions$,\n        ).pipe(\n          scan((prev, curr) => (mergeKeys(prev, mergeKeys)(curr)), state)\n        ) : merged$\n      ),\n      actions$: actions$ as ReducerObservables<Actions, DeepReadonly<S>>,\n    });\n  };\n}\n\ntype CreateRxState<S> = {\n  /**\n   * Allows to bind reducers to a state and an observable.\n   *\n   * Accepts a map of state reducers.\n   *\n   * Each reducer can either return:\n   * * an updated part of the state:\n   *   ```\n   *   (v) => ({ value: v })\n   *   ```\n   * * an observable that emits an updated part of the state:\n   *   ```\n   *   (v) => new BehaviorSubject({ value: v })\n   *   ```\n   * * a function that accepts the old state and returns either of the previous types:\n   *   ```\n   *   (v) => (oldState) => ({\n   *       value: oldState.value > v ? oldState.value : v\n   *   })\n   *   ```\n   *\n   * @param initialState an initial value for the reactive state\n   * @param mergeStrategy a strategy of merging a mutation with an old state\n   */\n  <R extends StateReducers<S>>(\n    reducers: R,\n    map$?: (\n      state$: Observable<S>,\n      reducers: R,\n      state: S,\n      actions$: Record<Action$<Extract<keyof R, string>>, Observable<S>>\n    ) => Observable<DeepPartial<S>>\n  ): SubscribableRxRes<ReducerActions<R>, S>;\n};\n\n/**\n * Checks if it's possible to advance deeper\n * into the sibling object structures,\n * with one being partial\n *\n * @param state - the object source\n * @param mutation - the main checking reference\n * @param key - a key into which to advance\n */\nexport const canMergeDeep = <S extends Record<PropertyKey, any>>(\n  state: S,\n  mutation: S | DeepPartial<S>,\n  key: keyof S,\n) =>  (\n  typeof mutation[key] === 'object'\n  && mutation !== null\n  && typeof state[key] === 'object'\n);\n\n/**\n * Default merge strategy for mutations\n *\n * Merges state and mutation recursively,\n * by enumerable keys (`for..in`),\n * so avoid recursive object links\n */\nexport const deepMergeKeys = <S extends Record<PropertyKey, any>>(\n  state: S\n) => (\n  mutation: DeepPartial<S>\n) => {\n  for (const key in mutation) {\n    state[key] = canMergeDeep(state, mutation, key)\n      ? deepMergeKeys(state[key])(mutation[key])\n      : mutation[key] as any;\n  }\n\n  return state;\n};\n\nconst defaultOptions: RxStateOptions<any> = {\n  mutationStrategy: deepMergeKeys,\n};\n\nconst createRxResult = <S, Actions>(result: {\n  actions: Actions,\n  state: DeepReadonly<S>,\n  state$: Observable<S>,\n  actions$: ReducerObservables<Actions, DeepReadonly<S>>\n}): SubscribableRxRes<Actions, S> => ({\n  ...result,\n  subscribe: (...args: any[]) => ({\n    ...result,\n    subscription: result.state$.subscribe(...args),\n  }),\n})\n\nconst maybeCall = <T, A extends any[]>(\n  fn: T | ((...args: A) => T),\n  ...args: A\n) => (\n  typeof fn === 'function'\n    ? (fn as (...args: A) => T)(...args)\n    : fn\n);\n\ntype Builtin =\n  | Function\n  | Date\n  | Error\n  | RegExp\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | bigint\n  | symbol\n  | undefined\n  | null;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends Record<any, any>\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRef<T>;\n\nexport type MutationContext = {\n  error(error: any): void;\n  complete(): void;\n}\n\nexport type Mutation<S> =\n  // | void\n  // isn't useful,\n  // need to keep reducers explicit in what they do\n  | S\n  | DeepPartial<S>\n  | Observable<DeepPartial<S>>;\n\n/**\n * A reducer for the observable state\n */\nexport type StateReducer<S, Args extends any[] = any[]> = (...args: Args) =>\n  | Mutation<S>\n  | ((state: S, mutation: MutationContext) => Mutation<S>)\n  ;\n\n/**\n * A named collection of state reducers\n */\nexport type StateReducers<S> = Record<string, StateReducer<S>>;\n\n/**\n * A method action generated from a StateReducer\n */\nexport type ResAction<A extends any[] = []> = (...args: A) => void;\n\n/**\n * Resulting RX bindings:\n *\n * * actions - a named collection of ResAction-s\n * * state - a reactive vue state\n * * state$ - an rxjs observable\n */\nexport type RxResult<\n  Actions,\n  State,\n  RState = DeepReadonly<State>\n> = {\n  readonly actions: Actions;\n  readonly state: RState;\n  readonly state$: Observable<State>;\n};\n\ntype Action$<Name extends string> = `${Name}$`;\n\ntype ReducerObservables<H, R> = {\n  [key in Action$<Extract<keyof H, string>>]: Observable<R>;\n};\n\nexport type SubscribableRxRes<\n  Actions,\n  State,\n  RState = DeepReadonly<State>\n> = RxResult<Actions, State, RState> & {\n  readonly actions$: ReducerObservables<Actions, RState>;\n  readonly subscribe: PipeSubscribe<SubscribableRxRes<Actions, State, RState>, State>;\n};\n\nexport type PipeSubscribe<Res extends SubscribableRxRes<any, any>, S> = {\n  (observer?: PartialObserver<S>): Omit<Res, 'subscribe'> & {\n    readonly subscription: Subscription;\n  };\n  (...args: Parameters<Observable<S>['subscribe']>): Omit<Res, 'subscribe'> & {\n    readonly subscription: Subscription;\n  };\n};\n\ntype ReducerAction<R> = R extends StateReducer<any, infer Args>\n  ? ResAction<Args>\n  : never;\n\ntype ReducerActions<R> = { [key in keyof R]: ReducerAction<R[key]> };\n","import type { Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nexport const createErrorOperator = (\n  operation: (e: any, $: Observable<any>, cb: (e: any, $: Observable<any>) => any) => void\n) => <T, O, R>(cb: (e: T, $: Observable<O>) => R) => (\n  catchError<O, Observable<O>>((e, $) => { throw operation(e, $, cb); })\n);\n","import { createErrorOperator } from './error-utils';\n\nexport const mapError = createErrorOperator((e, $, cb) => cb(e, $));\n","import { createErrorOperator } from './error-utils';\n\nexport const tapError = createErrorOperator((e, $, cb) => (cb(e, $), e));\n","import { Observable } from 'rxjs';\nimport { watch, WatchOptions, WatchSource } from 'vue';\nimport { untilUnmounted } from '../hooks/until';\n\n/**\n * Creates an observable from a vue ref.\n *\n * Each time a ref's value is changed - observable emits.\n *\n * Can also accept vue reactive objects and value factories.\n *\n * @param ref - a ref/reactive/factory to observe\n * @returns an observable that watches the ref\n */\nexport function fromRef<R>(ref: WatchSource<R>, options?: WatchOptions): Observable<R>;\n\n/**\n * Creates an observable from a vue reactive state.\n *\n * Each time a state's value is changed - observable emits.\n *\n * @param ref - a reactive state to observe\n * @returns an observable that watches the state\n */\nexport function fromRef<R extends Record<string, any>>(reactiveState: R, options?: WatchOptions): Observable<R>;\nexport function fromRef<R extends Record<string, any> | WatchSource<any>>(ref: R): Observable<R> {\n  return untilUnmounted(\n    new Observable<R>(ctx => watch(ref, value => ctx.next(value)))\n  );\n};\n","import { from, ObservableInput } from 'rxjs';\nimport { isProxy, Ref, ref, toRef, UnwrapRef } from 'vue';\n\n/**\n * Creates a ref from a promise.\n *\n * Once a promise is resolved, the ref is set to the resulting value.\n *\n * The ref will contain `undefined` until the promise is resolved.\n *\n * @param promise to set from\n */\nexport function refFrom<R>(promise: Promise<R>): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * Creates a ref from a promise.\n *\n * Once a promise is fulfilled, the ref is set to the resulting value.\n * Until then, the ref will contain the passed default value.\n *\n * @param promise to set from\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(promise: Promise<R>, defaultValue: R): Ref<UnwrapRef<R>>;\n\n/**\n * Creates a ref from an observable input.\n *\n * Behaves exactly like `from` in rxjs and creates an observable from the input.\n *\n * Once a resulting observable emits, the ref is set to the emitted value.\n *\n * The ref will contain `undefined` until the observable emits.\n *\n * @param observableInput an input to create an observable form and then listen to it\n */\nexport function refFrom<R>(obserableInput: ObservableInput<R>): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * Creates a ref from an observable input.\n *\n * Behaves exactly like `from` in rxjs and creates an observable from the input.\n *\n * Once a resulting observable emits, the ref is set to the emitted value.\n * Until then, the ref will contain the passed default value.\n *\n * @param observableInput an input to create an observable form and then listen to it\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(obserableInput: ObservableInput<R>, defaultValue: R): Ref<UnwrapRef<R>>;\n\n/**\n * Works exactly like toRef:\n * creates a ref from a reactive state.\n *\n * @param state a reactive state to bind from\n * @param key a key of the state to bind\n */\nexport function refFrom<R extends Record<any, any>, K extends keyof R>(state: R, key: K): Ref<UnwrapRef<R[K]>>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n */\nexport function refFrom<R>(arg: ObservableInput<R> | R): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(arg: ObservableInput<R> | R, defaultValue: R): Ref<UnwrapRef<R>>;\n\nexport function refFrom(arg: unknown, subArg?: unknown) {\n  if (typeof arg === 'object') try {\n    const ref$ = ref(subArg);\n\n    from(arg as any).subscribe(value => ref$.value = value);\n\n    return ref$;\n  } catch (_) { /* Silence the error to try another ways */ }\n\n  return isProxy(arg)\n    ? toRef(arg as Record<any, any>, subArg)\n    : ref(arg);\n}\n","import { ObservableInput, from } from 'rxjs';\nimport { Ref, ref } from 'vue';\n\ntype Subscribers<R, E> = { next: R; error: E; };\n\ntype Refs<S extends Subscribers<unknown, unknown>> = {\n  [key in keyof S]: Ref<S[key]>;\n};\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * Until the observable emits, the refs will contain `undefined`.\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n */\nexport function refsFrom<R, E = unknown>(input: ObservableInput<R>): Refs<Subscribers<R | undefined, E | undefined>>;\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n *\n * @param defaultValues\n * A map of default values for each ref.\n */\nexport function refsFrom<R, E = unknown>(input: ObservableInput<R>, defaultValues: { next: R }): Refs<Subscribers<R, E | undefined>>;\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n *\n * @param defaultValues\n * A map of default values for each ref.\n */\nexport function refsFrom<R, E>(input: ObservableInput<R>, defaultValues: Subscribers<R, E>): Refs<Subscribers<R, E>>;\n\nexport function refsFrom(input: ObservableInput<any>, defaultValues?: Partial<Subscribers<any, any>>) {\n  const next = ref(defaultValues?.next);\n  const error = ref(defaultValues?.error);\n\n  from(input).subscribe({\n    next: v => next.value = v,\n    error: v => error.value = v,\n  });\n\n  return { next, error };\n}\n","import { tap } from 'rxjs/operators';\nimport { Ref } from 'vue';\n\nexport const setRef = <T>(ref: Ref<T>) => tap<T>(v => ref.value = v);\n","import { Ref, UnwrapRef, computed, ref, watch } from 'vue';\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The resulting ref serves as an origin point for the binding,\\\n * values **from** the resulting ref and **to** the resulting ref are mapped onto it.\n */\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { to, from }: Mappers<R1, UnwrapRef<R2>>,\n  defaultValue?: R2,\n): Ref<UnwrapRef<R2>>;\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The resulting ref serves as an origin point for the binding,\\\n * values **from** the resulting ref and **to** the resulting ref are mapped onto it.\n */\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { to, from }: Mappers<R1, UnwrapRef<R2>>,\n): Ref<UnwrapRef<R2>>;\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The second ref serves as an origin point for the binding,\\\n * values **from** the second ref and **to** the second ref are mapped onto it.\n */\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { to, from }: Mappers<R1, R2>,\n  ref2: Ref<R2>,\n): Ref<R2>;\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { to, from }: Mappers<R1, R2>,\n  _ref2?: Ref<R2> | R2,\n): Ref<R2> {\n  // Slight optimization if both mappers are defined\n  if (to && from) {\n    return computed({\n      get: () => to(ref1.value),\n      set: v => ref1.value = from(v),\n    });\n  }\n\n  const ref2 = ref(_ref2 ?? ref1.value) as Ref<R2>;\n\n  if (to) {\n    watch(ref1, v => ref2.value = to(v));\n  } else if (from) {\n    watch(ref2, v => ref1.value = from(v));\n  }\n\n  return ref2;\n}\n\ntype Mapper<F, T> = (value: F) => T;\n\ntype Mappers<R1, R2> = {\n  /**\n   * A map from the first ref to the second\n   */\n  to: Mapper<R1, R2>,\n\n  /**\n   * A map from the second ref to the first\n   *\n   * It will create a two-way bind between the refs\n   */\n  from?: Mapper<R2, R1>,\n} | {\n  /**\n   * A map from the first ref to the second\n   */\n  to?: Mapper<R1, R2>,\n\n  /**\n   * A map from the second ref to the first\n   *\n   * It will create a two-way bind between the refs\n   */\n  from: Mapper<R2, R1>,\n};\n"],"names":["fromHook","hook","Observable","ctx","getCurrentInstance","next","pipeUntil","takeUntil","untilUnmounted","obs","pipe","onUnmounted","canMergeDeep","state","mutation","key","_typeof","deepMergeKeys","defaultOptions","mutationStrategy","createRxResult","result","subscribe","subscription","state$","maybeCall","fn","args","createErrorOperator","operation","cb","catchError","e","$","mapError","tapError","ref","watch","value","arg","subArg","ref$","from","_","isProxy","toRef","input","defaultValues","error","v","tap","ref1","_ref2","to","computed","get","set","ref2","initialState","options","mergeKeys","reducers","map$","reactive","actions","actions$","actions$Arr","mutations$","Subject","apply","push","mergeScan","prev","curr","complete","undefined","isObservable","of","map","merged$","merge","readonly","scan"],"mappings":"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"}